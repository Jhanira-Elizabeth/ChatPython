#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Chatbot de Turismo para Santo Domingo de los Ts√°chilas - Versi√≥n Azure
Configurado para despliegue en Azure App Service con Azure Database for PostgreSQL
"""

from flask import Flask, request, jsonify
import json
import re
import spacy
import os
import psycopg2
from urllib.parse import urlparse
from fuzzywuzzy import process, fuzz

# --- Global Dictionaries to store parsed data ---
puntos_turisticos = {}
parroquias_info = {}
locales_servicios = {}
etiquetas_info = {}

# --- Inicializa la aplicaci√≥n Flask ---
app = Flask(__name__)

# --- Configuraci√≥n de Base de Datos para Azure ---
def get_db_connection():
    """
    Configuraci√≥n de conexi√≥n a Azure Database for PostgreSQL
    """
    # URL de conexi√≥n de Azure
    azure_db_url = "postgresql://tursd:elizabeth18.@tursd.postgres.database.azure.com:5432/tursd?sslmode=require"
    
    try:
        # Parsear la URL de conexi√≥n
        parsed = urlparse(azure_db_url)
        
        conn = psycopg2.connect(
            host=parsed.hostname,
            database=parsed.path[1:],  # Remover el '/' inicial
            user=parsed.username,
            password=parsed.password,
            port=parsed.port,
            sslmode='require'  # Importante para Azure
        )
        return conn
    except Exception as e:
        print(f"‚ùå Error conectando a Azure PostgreSQL: {e}")
        return None

# --- Generar datos desde Azure Database ---
def load_data_from_azure_db():
    """
    Carga datos directamente desde Azure Database for PostgreSQL
    """
    print("üîÑ Conectando a Azure Database for PostgreSQL...")
    
    conn = get_db_connection()
    if not conn:
        print("‚ùå No se pudo conectar a la base de datos de Azure")
        return False
    
    try:
        cursor = conn.cursor()
        
        # Consulta para obtener informaci√≥n completa de puntos tur√≠sticos
        query_puntos = """
        SELECT 
            pt.id,
            pt.nombre,
            pt.descripcion,
            pt.latitud,
            pt.longitud,
            p.nombre as parroquia,
            COALESCE(STRING_AGG(DISTINCT CONCAT(a.actividad, 
                CASE WHEN a.precio IS NOT NULL THEN CONCAT(' (Precio: $', a.precio, ')') ELSE '' END,
                CASE WHEN a.tipo IS NOT NULL THEN CONCAT(' - Tipo: ', a.tipo) ELSE '' END), '; '), '') as actividades,
            COALESCE(STRING_AGG(DISTINCT et.nombre, ', '), '') as etiquetas
        FROM puntos_turisticos pt
        LEFT JOIN parroquias p ON pt.id_parroquia = p.id AND p.estado = 'activo'
        LEFT JOIN puntos_turisticos_etiqueta pte ON pt.id = pte.id_punto_turistico AND pte.estado = 'activo'
        LEFT JOIN etiquetas_turisticas et ON pte.id_etiqueta = et.id AND et.estado = 'activo'
        LEFT JOIN actividad_punto_turistico a ON pt.id = a.id_punto_turistico AND a.estado = 'activo'
        WHERE pt.estado = 'activo'
        GROUP BY pt.id, pt.nombre, pt.descripcion, pt.latitud, pt.longitud, p.nombre
        ORDER BY pt.id;
        """
        
        print("üîç Ejecutando consulta para puntos tur√≠sticos...")
        cursor.execute(query_puntos)
        puntos_data = cursor.fetchall()
        print(f"‚úÖ Encontrados {len(puntos_data)} puntos tur√≠sticos")
        
        # Procesar datos de puntos tur√≠sticos
        for row in puntos_data:
            punto_id, nombre, descripcion, latitud, longitud, parroquia, actividades, etiquetas = row
            
            # Procesar actividades
            actividades_list = []
            if actividades and actividades.strip():
                for act in actividades.split(';'):
                    if act.strip():
                        actividades_list.append({"nombre": act.strip()})
            
            # Procesar etiquetas
            etiquetas_list = []
            if etiquetas and etiquetas.strip():
                etiquetas_list = [etq.strip() for etq in etiquetas.split(',') if etq.strip()]
            
            # Guardar en diccionario global
            puntos_turisticos[nombre] = {
                "id": punto_id,
                "parroquia": parroquia or "N/A",
                "descripcion": descripcion or "No disponible",
                "latitud": latitud,
                "longitud": longitud,
                "actividades": actividades_list,
                "etiquetas": etiquetas_list
            }
            
            # Asociar con parroquia
            if parroquia:
                if parroquia not in parroquias_info:
                    parroquias_info[parroquia] = {"puntos_turisticos": []}
                if nombre not in parroquias_info[parroquia]["puntos_turisticos"]:
                    parroquias_info[parroquia]["puntos_turisticos"].append(nombre)
        
        # Consulta para obtener informaci√≥n de parroquias
        query_parroquias = """
        SELECT 
            p.nombre,
            p.descripcion,
            p.poblacion,
            p.temperatura_promedio
        FROM parroquias p
        WHERE p.estado = 'activo'
        ORDER BY p.nombre;
        """
        
        print("üîç Ejecutando consulta para parroquias...")
        cursor.execute(query_parroquias)
        parroquias_data = cursor.fetchall()
        print(f"‚úÖ Encontradas {len(parroquias_data)} parroquias")
        
        # Procesar datos de parroquias
        for row in parroquias_data:
            nombre, descripcion, poblacion, temperatura = row
            
            if nombre not in parroquias_info:
                parroquias_info[nombre] = {"puntos_turisticos": []}
            
            parroquias_info[nombre].update({
                "descripcion": descripcion or "No disponible",
                "poblacion": poblacion or "N/A",
                "temperatura": temperatura or "N/A"
            })
        
        conn.close()
        print("‚úÖ Datos cargados exitosamente desde Azure Database")
        return True
        
    except Exception as e:
        print(f"‚ùå Error cargando datos desde Azure: {e}")
        conn.close()
        return False

# --- Carga el modelo spaCy y los datos tur√≠sticos SOLO UNA VEZ al iniciar la app ---
try:
    nlp = spacy.load("es_core_news_sm")
    print("‚úÖ Modelo spaCy cargado correctamente")
except OSError:
    print("‚ö†Ô∏è Modelo spaCy no encontrado. Intentando descargarlo...")
    try:
        import subprocess
        subprocess.run(["python", "-m", "spacy", "download", "es_core_news_sm"], check=True)
        nlp = spacy.load("es_core_news_sm")
        print("‚úÖ Modelo spaCy descargado y cargado correctamente")
    except Exception as e:
        print(f"‚ùå Error descargando modelo spaCy: {e}")
        # Crear un objeto mock para evitar errores
        class MockNLP:
            def __call__(self, text):
                class MockDoc:
                    ents = []
                return MockDoc()
        nlp = MockNLP()

# --- Cargar datos al iniciar la aplicaci√≥n ---
print("üöÄ Iniciando Chatbot de Turismo para Azure")
print("=" * 60)

# Intentar cargar desde base de datos de Azure
if not load_data_from_azure_db():
    print("‚ö†Ô∏è Fallback: intentando cargar desde archivo local...")
    # Fallback al archivo local si la DB no est√° disponible
    try:
        file_path = 'turismo_data_completo_v2.jsonl'
        with open(file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
            print(f"‚úÖ Archivo local encontrado con {len(lines)} l√≠neas")
        # Aqu√≠ puedes agregar la l√≥gica de procesamiento del archivo local si es necesario
    except FileNotFoundError:
        print("‚ùå No se pudo cargar datos ni de Azure DB ni de archivo local")

# Mostrar estad√≠sticas
print(f"\n=== ESTAD√çSTICAS DE DATOS CARGADOS ===")
print(f"üìç Puntos tur√≠sticos: {len(puntos_turisticos)}")
print(f"üèòÔ∏è Parroquias: {len(parroquias_info)}")
print(f"üè™ Locales/servicios: {len(locales_servicios)}")
print(f"üè∑Ô∏è Etiquetas: {len(etiquetas_info)}")
print("=" * 60)

# --- Funciones de Procesamiento del Lenguaje Natural (NLU) ---
def reconocer_intencion(texto):
    """Reconoce la intenci√≥n del usuario"""
    texto_lower = texto.lower()

    if any(palabra in texto_lower for palabra in ["cu√©ntame sobre", "informaci√≥n de", "dime sobre", "dame informaci√≥n de", "quiero saber de"]):
        return "informacion_general_lugar"
    elif any(palabra in texto_lower for palabra in ["qu√© puedo hacer", "actividades en", "actividades para"]):
        return "buscar_actividades"
    elif any(palabra in texto_lower for palabra in ["qu√© servicios ofrece", "servicios de", "qu√© hay en"]):
        return "buscar_servicios_local"
    elif any(palabra in texto_lower for palabra in ["dame informaci√≥n detallada sobre la parroquia", "cu√©ntame de la parroquia", "sobre la parroquia"]):
        return "informacion_parroquia"
    elif any(palabra in texto_lower for palabra in ["qu√© significa la etiqueta", "definici√≥n de", "explica la etiqueta"]):
        return "explicar_etiqueta"
    elif any(palabra in texto_lower for palabra in ["cu√°l es el horario de", "cu√°ndo abre", "horario de atenci√≥n de"]):
        return "consultar_horario"
    elif any(palabra in texto_lower for palabra in ["qu√© etiquetas tiene", "etiquetas de"]):
        return "listar_etiquetas"
    elif any(palabra in texto_lower for palabra in ["hola", "saludos", "qu√© tal", "buenos d√≠as", "buenas tardes", "buenas noches"]):
        return "saludo"
    elif any(palabra in texto_lower for palabra in ["gracias", "agradezco", "te lo agradezco"]):
        return "agradecimiento"
    elif any(palabra in texto_lower for palabra in ["adi√≥s", "chau", "hasta luego", "nos vemos", "bye"]):
        return "despedida"

    entidades_detectadas = extraer_entidades(texto)
    if entidades_detectadas.get("lugar_turistico") or \
       entidades_detectadas.get("local_turistico") or \
       entidades_detectadas.get("parroquia") or \
       entidades_detectadas.get("nombre_etiqueta") or \
       entidades_detectadas.get("ambiguous_entity"):
        return "informacion_general_lugar" 

    return "desconocida"

def extraer_entidades(texto):
    """Extrae entidades nombradas del texto"""
    entidades = {}
    texto_lower = texto.lower()

    all_known_names = (
        list(puntos_turisticos.keys()) +
        list(locales_servicios.keys()) +
        list(parroquias_info.keys()) +
        list(etiquetas_info.keys())
    )

    # Buscar coincidencias exactas
    for name in all_known_names:
        if name.lower() == texto_lower:
            if name in puntos_turisticos:
                entidades["lugar_turistico"] = name
            elif name in locales_servicios:
                entidades["local_turistico"] = name
            elif name in parroquias_info:
                entidades["parroquia"] = name
            elif name in etiquetas_info:
                entidades["nombre_etiqueta"] = name
            return entidades

    # Buscar coincidencias parciales usando fuzzy matching
    if all_known_names:  # Solo si hay datos cargados
        potential_matches = process.extract(texto, all_known_names, limit=5, scorer=fuzz.partial_ratio)

        relevant_matches = []
        score_cutoff = 70
        for matched_name, score in potential_matches:
            if score >= score_cutoff:
                relevant_matches.append((matched_name, score))

        if relevant_matches:
            relevant_matches.sort(key=lambda x: x[1], reverse=True)
            best_match_name, best_score = relevant_matches[0]

            if len(relevant_matches) > 1:
                filtered_matches = []
                for name, score in relevant_matches:
                    if score >= (best_score - 10):
                        is_substring = False
                        for other_name, other_score in relevant_matches:
                            if (name != other_name and 
                                abs(score - other_score) <= 10 and
                                (name.lower() in other_name.lower() or other_name.lower() in name.lower())):
                                if len(other_name) > len(name):
                                    is_substring = True
                                    break
                        
                        if not is_substring:
                            filtered_matches.append((name, score))
                
                if len(filtered_matches) > 1:
                    entidades["ambiguous_entity"] = [name for name, score in filtered_matches]
                    return entidades
                elif len(filtered_matches) == 1:
                    best_match_name = filtered_matches[0][0]

            if best_match_name in puntos_turisticos:
                entidades["lugar_turistico"] = best_match_name
            elif best_match_name in locales_servicios:
                entidades["local_turistico"] = best_match_name
            elif best_match_name in parroquias_info:
                entidades["parroquia"] = best_match_name
            elif best_match_name in etiquetas_info:
                entidades["nombre_etiqueta"] = best_match_name
            return entidades

    return entidades

def generar_respuesta(intencion, entidades):
    """Genera respuesta basada en la intenci√≥n y entidades"""
    respuesta = "ü§î ¬°Hola! Me encantar√≠a ayudarte, pero no estoy seguro de lo que buscas exactamente.\n\n"
    respuesta += "üí° **Puedo ayudarte con:**\n"
    respuesta += "   ‚Ä¢ üèûÔ∏è Informaci√≥n sobre puntos tur√≠sticos\n"
    respuesta += "   ‚Ä¢ üèòÔ∏è Detalles de parroquias\n"
    respuesta += "   ‚Ä¢ üè™ Servicios de locales tur√≠sticos\n"
    respuesta += "   ‚Ä¢ üéØ Actividades disponibles\n"
    respuesta += "   ‚Ä¢ üè∑Ô∏è Significado de etiquetas\n"
    respuesta += "   ‚Ä¢ üïê Horarios de atenci√≥n\n\n"
    respuesta += "üó∫Ô∏è ¬øPodr√≠as reformular tu pregunta o decirme espec√≠ficamente qu√© te gustar√≠a saber sobre Santo Domingo de los Ts√°chilas? ¬°Estoy aqu√≠ para ayudarte! üòä"

    if "ambiguous_entity" in entidades and entidades["ambiguous_entity"]:
        if len(entidades["ambiguous_entity"]) > 1:
            respuesta = f"¬°Perfecto! üéØ Veo que tenemos varias opciones fant√°sticas relacionadas con tu b√∫squeda:\n\n"
            for i, nombre in enumerate(entidades["ambiguous_entity"], 1):
                respuesta += f"   {i}. {nombre}\n"
            respuesta += f"\n‚ú® Cada uno de estos lugares tiene caracter√≠sticas √∫nicas y especiales. ¬øPodr√≠as decirme espec√≠ficamente sobre cu√°l te gustar√≠a saber m√°s?\n\n"
            respuesta += f"¬°Estoy emocionado de contarte todos los detalles! üòä"
            return respuesta

    if intencion == "saludo":
        respuesta = "¬°Hola! üëã ¬°Qu√© gusto saludarte! Soy tu asistente tur√≠stico personal de Santo Domingo de los Ts√°chilas. üåø\n\n"
        respuesta += "üó∫Ô∏è Estoy aqu√≠ para ayudarte a descubrir los lugares m√°s incre√≠bles de nuestra hermosa provincia. Puedo contarte sobre:\n"
        respuesta += "   ‚Ä¢ üèûÔ∏è Puntos tur√≠sticos imperdibles\n"
        respuesta += "   ‚Ä¢ üèòÔ∏è Parroquias y sus caracter√≠sticas\n"
        respuesta += "   ‚Ä¢ üéØ Actividades emocionantes\n"
        respuesta += "   ‚Ä¢ üè™ Locales y sus servicios\n"
        respuesta += "   ‚Ä¢ üïê Horarios de atenci√≥n\n\n"
        respuesta += "¬øSobre qu√© lugar o experiencia te gustar√≠a saber? ¬°Estoy emocionado de ayudarte! üòä"

    elif intencion == "informacion_general_lugar":
        lugar = entidades.get("lugar_turistico")
        parroquia = entidades.get("parroquia")

        if lugar and lugar in puntos_turisticos:
            info = puntos_turisticos[lugar]
            respuesta = f"¬°Excelente elecci√≥n! üåü **{lugar}** es un hermoso punto tur√≠stico ubicado en la parroquia **{info.get('parroquia', 'desconocida')}**.\n\n"
            respuesta += f"üìç **Descripci√≥n:** {info.get('descripcion', 'No hay descripci√≥n disponible.')}\n\n"
            
            if info.get("actividades"):
                respuesta += f"üéØ **Actividades disponibles:**\n"
                for act in info["actividades"]:
                    respuesta += f"   ‚Ä¢ {act['nombre']}\n"
                respuesta += "\n"
            
            if info.get("etiquetas") and len(info["etiquetas"]) > 0:
                respuesta += f"üè∑Ô∏è **Caracter√≠sticas:** {', '.join(info['etiquetas'])}\n\n"
            
            respuesta += f"‚ú® ¬°Es un lugar que definitivamente no te puedes perder! Te recomiendo visitarlo para disfrutar de una experiencia √∫nica en Santo Domingo de los Ts√°chilas.\n\n"
            respuesta += f"¬øTe gustar√≠a saber m√°s sobre las actividades espec√≠ficas que puedes realizar aqu√≠? üòä"

        elif parroquia and parroquia in parroquias_info:
            info = parroquias_info[parroquia]
            puntos_relacionados = info.get("puntos_turisticos", [])
            respuesta = f"¬°Qu√© buena elecci√≥n! üèòÔ∏è Te voy a contar sobre la hermosa parroquia **{parroquia}**.\n\n"
            respuesta += f"üåø **Caracter√≠sticas:** {info.get('descripcion', 'No hay descripci√≥n disponible.')}\n\n"
            respuesta += f"üë• **Poblaci√≥n:** Aproximadamente **{info.get('poblacion', 'N/A')}** habitantes\n"
            respuesta += f"üå°Ô∏è **Temperatura promedio:** **{info.get('temperatura', 'N/A')}** (¬°clima muy agradable!)\n\n"
            
            if puntos_relacionados:
                respuesta += f"üéØ **Lugares tur√≠sticos que puedes visitar:**\n"
                for punto in puntos_relacionados:
                    respuesta += f"   ‚Ä¢ {punto}\n"
                respuesta += "\n"
            
            respuesta += f"‚ú® ¬°Es una parroquia encantadora que definitivamente vale la pena visitar! ¬øTe gustar√≠a saber m√°s sobre alg√∫n lugar espec√≠fico de esta zona? üòä"

    elif intencion == "buscar_actividades":
        lugar = entidades.get("lugar_turistico")
        if lugar and lugar in puntos_turisticos and puntos_turisticos[lugar].get("actividades"):
            actividades = puntos_turisticos[lugar]["actividades"]
            respuesta = f"¬°Fant√°stico! üéØ En **{lugar}** tienes muchas opciones emocionantes para disfrutar:\n\n"
            respuesta += f"üé™ **Actividades disponibles:**\n"
            
            for act in actividades:
                respuesta += f"   ‚Ä¢ {act['nombre']}\n"
            
            respuesta += f"\n‚ú® ¬°Cada una de estas actividades te brindar√° una experiencia √∫nica! Te recomiendo planificar tu visita con tiempo para que puedas disfrutar al m√°ximo.\n\n"
            respuesta += f"¬øTe interesa alguna actividad en particular? ¬°Puedo darte m√°s detalles! üòä"

    return respuesta

# --- Endpoints de la API ---
@app.route('/', methods=['GET'])
def home():
    """Endpoint de bienvenida"""
    return jsonify({
        "message": "üåü Chatbot de Turismo - Santo Domingo de los Ts√°chilas",
        "version": "2.0 - Azure Edition",
        "status": "active",
        "endpoints": {
            "chat": "/chatbot (POST)",
            "health": "/health (GET)"
        },
        "stats": {
            "puntos_turisticos": len(puntos_turisticos),
            "parroquias": len(parroquias_info),
            "locales": len(locales_servicios)
        }
    })

@app.route('/health', methods=['GET'])
def health():
    """Endpoint de health check"""
    return jsonify({
        "status": "healthy",
        "database": "azure_postgresql",
        "data_loaded": {
            "puntos_turisticos": len(puntos_turisticos),
            "parroquias": len(parroquias_info),
            "locales": len(locales_servicios)
        },
        "version": "2.0"
    })

@app.route('/chatbot', methods=['POST'])
def chatbot_api():
    """Endpoint principal del chatbot"""
    try:
        data = request.get_json()
        user_message = data.get('message', '').strip()
        
        if not user_message:
            return jsonify({'error': 'Mensaje vac√≠o'}), 400

        print(f"üîç Pregunta recibida: {user_message}")

        # Procesar mensaje
        intencion = reconocer_intencion(user_message)
        entidades = extraer_entidades(user_message)
        response_text = generar_respuesta(intencion, entidades)

        print(f"‚úÖ Respuesta generada: {response_text[:100]}...")

        return jsonify({
            "response": response_text,
            "status": "success",
            "intent": intencion,
            "entities": entidades
        })

    except Exception as e:
        print(f"‚ùå Error en /chatbot: {e}")
        return jsonify({
            'error': 'Error interno del servidor',
            'message': 'Lo siento, hubo un problema procesando tu mensaje. Por favor intenta de nuevo.'
        }), 500

# --- Punto de entrada ---
if __name__ == '__main__':
    # Configuraci√≥n para Azure App Service
    port = int(os.environ.get('PORT', 5000))
    debug_mode = os.environ.get('FLASK_DEBUG', 'False').lower() == 'true'
    
    print(f"üöÄ Iniciando servidor en puerto {port}")
    print(f"üîß Modo debug: {debug_mode}")
    
    app.run(
        debug=debug_mode,
        host='0.0.0.0',
        port=port
    )
